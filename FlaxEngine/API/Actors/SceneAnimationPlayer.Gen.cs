// Copyright (c) 2012-2019 Wojciech Figat. All rights reserved.
// This code was generated by a tool. Changes to this file may cause
// incorrect behavior and will be lost if the code is regenerated.

using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace FlaxEngine
{
    /// <summary>
    /// The scene animation playback actor.
    /// </summary>
    [Serializable]
    public sealed partial class SceneAnimationPlayer : Actor
    {
        /// <summary>
        /// Creates new <see cref="SceneAnimationPlayer"/> object.
        /// </summary>
        private SceneAnimationPlayer() : base()
        {
        }

        /// <summary>
        /// Creates new instance of <see cref="SceneAnimationPlayer"/> object.
        /// </summary>
        /// <returns>Created object.</returns>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static SceneAnimationPlayer New()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            return Internal_Create(typeof(SceneAnimationPlayer)) as SceneAnimationPlayer;
#endif
        }

        /// <summary>
        /// Gets or sets the scene animation to play.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(0), DefaultValue(null), Tooltip("The scene animation to play.")]
        public SceneAnimation Animation
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetAnimation(unmanagedPtr); }
            set { Internal_SetAnimation(unmanagedPtr, FlaxEngine.Object.GetUnmanagedPtr(value)); }
#endif
        }

        /// <summary>
        /// Gets or sets the animation playback speed factor. Scales the timeline update delta time. Can be used to speed up or slow down the sequence.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(10), DefaultValue(1.0f), Tooltip("The animation playback speed factor. Scales the timeline update delta time. Can be used to speed up or slow down the sequence.")]
        public float Speed
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetSpeed(unmanagedPtr); }
            set { Internal_SetSpeed(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the animation start time. Can be used to skip part of the sequence on begin.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(20), DefaultValue(0.0f), Tooltip("The animation start time. Can be used to skip part of the sequence on begin.")]
        public float StartTime
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetStartTime(unmanagedPtr); }
            set { Internal_SetStartTime(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should take into account the global game time scale for simulation updates.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(30), DefaultValue(true), Tooltip("Determines whether the scene animation should take into account the global game time scale for simulation updates.")]
        public bool UseTimeScale
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetUseTimeScale(unmanagedPtr); }
            set { Internal_SetUseTimeScale(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should loop when it finishes playing.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(40), DefaultValue(false), Tooltip("Determines whether the scene animation should loop when it finishes playing.")]
        public bool Loop
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetLoop(unmanagedPtr); }
            set { Internal_SetLoop(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should auto play on game start.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation", "Play On Start"), EditorOrder(50), DefaultValue(false), Tooltip("Determines whether the scene animation should auto play on game start.")]
        public bool PlayOnStart
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetPlayOnStart(unmanagedPtr); }
            set { Internal_SetPlayOnStart(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should randomize the start time on play begin.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(60), DefaultValue(false), Tooltip("Determines whether the scene animation should randomize the start time on play begin.")]
        public bool RandomStartTime
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetRandomStartTime(unmanagedPtr); }
            set { Internal_SetRandomStartTime(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should restore initial state on playback stop. State is cached when animation track starts play after being stopped (not paused).
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation", "Restore State On Stop"), EditorOrder(70), DefaultValue(false), Tooltip("Determines whether the scene animation should restore initial state on playback stop. State is cached when animations stats play after being stopped (not paused).")]
        public bool RestoreStateOnStop
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetRestoreStateOnStop(unmanagedPtr); }
            set { Internal_SetRestoreStateOnStop(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets the value that determinates whether the scene animation is playing.
        /// </summary>
        [UnmanagedCall]
        public bool IsPlaying
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetIsPlaying(unmanagedPtr); }
#endif
        }

        /// <summary>
        /// Gets the value that determinates whether the scene animation is paused.
        /// </summary>
        [UnmanagedCall]
        public bool IsPaused
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetIsPaused(unmanagedPtr); }
#endif
        }

        /// <summary>
        /// Gets the value that determinates whether the scene animation is stopped.
        /// </summary>
        [UnmanagedCall]
        public bool IsStopped
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetIsStopped(unmanagedPtr); }
#endif
        }

        /// <summary>
        /// Gets or sets the current animation playback time position (seconds).
        /// </summary>
        [UnmanagedCall]
        [NoSerialize, HideInEditor]
        public float Time
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetTime(unmanagedPtr); }
            set { Internal_SetTime(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Starts playing the animation. Has no effect if animation is already playing.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public void Play()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Play(unmanagedPtr);
#endif
        }

        /// <summary>
        /// Pauses the animation. Has no effect if animation is not playing.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public void Pause()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Pause(unmanagedPtr);
#endif
        }

        /// <summary>
        /// Stops playing the animation. Has no effect if animation is already stopped.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public void Stop()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Stop(unmanagedPtr);
#endif
        }

        #region Internal Calls

#if !UNIT_TEST_COMPILANT
        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern SceneAnimation Internal_GetAnimation(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetAnimation(IntPtr obj, IntPtr val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern float Internal_GetSpeed(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetSpeed(IntPtr obj, float val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern float Internal_GetStartTime(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetStartTime(IntPtr obj, float val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetUseTimeScale(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetUseTimeScale(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetLoop(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetLoop(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetPlayOnStart(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetPlayOnStart(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetRandomStartTime(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetRandomStartTime(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetRestoreStateOnStop(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetRestoreStateOnStop(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetIsPlaying(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetIsPaused(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetIsStopped(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern float Internal_GetTime(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetTime(IntPtr obj, float val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Play(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Pause(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Stop(IntPtr obj);
#endif

        #endregion
    }
}

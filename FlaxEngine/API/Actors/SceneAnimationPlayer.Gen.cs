// Copyright (c) 2012-2019 Wojciech Figat. All rights reserved.
// This code was generated by a tool. Changes to this file may cause
// incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Runtime.CompilerServices;

namespace FlaxEngine
{
    /// <summary>
    /// The scene animation playback actor.
    /// </summary>
    [Serializable]
    public sealed partial class SceneAnimationPlayer : Actor
    {
        /// <summary>
        /// Creates new <see cref="SceneAnimationPlayer"/> object.
        /// </summary>
        private SceneAnimationPlayer() : base()
        {
        }

        /// <summary>
        /// Creates new instance of <see cref="SceneAnimationPlayer"/> object.
        /// </summary>
        /// <returns>Created object.</returns>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static SceneAnimationPlayer New()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            return Internal_Create(typeof(SceneAnimationPlayer)) as SceneAnimationPlayer;
#endif
        }

        /// <summary>
        /// Gets or sets the scene animation to play.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(0), Tooltip("The scene animation to play.")]
        public SceneAnimation Animation
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetAnimation(unmanagedPtr); }
            set { Internal_SetAnimation(unmanagedPtr, Object.GetUnmanagedPtr(value)); }
#endif
        }

        /// <summary>
        /// Gets or sets the animation playback speed factor. Scales the timeline update delta time. Can be used to speed up or slow down the sequence.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(10), Tooltip("The animation playback speed factor. Scales the timeline update delta time. Can be used to speed up or slow down the sequence.")]
        public float Speed
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetSpeed(unmanagedPtr); }
            set { Internal_SetSpeed(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the animation start time. Can be used to skip part of the sequence on begin.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(20), Tooltip("The animation start time. Can be used to skip part of the sequence on begin.")]
        public float StartTime
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetStartTime(unmanagedPtr); }
            set { Internal_SetStartTime(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should take into account the global game time scale for simulation updates.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(30), Tooltip("Determines whether the scene animation should take into account the global game time scale for simulation updates.")]
        public bool UseTimeScale
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetUseTimeScale(unmanagedPtr); }
            set { Internal_SetUseTimeScale(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should loop when it finishes playing.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(40), Tooltip("Determines whether the scene animation should loop when it finishes playing.")]
        public bool Loop
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetLoop(unmanagedPtr); }
            set { Internal_SetLoop(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should auto play on game start.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation", "Play On Start"), EditorOrder(50), Tooltip("Determines whether the scene animation should auto play on game start.")]
        public bool PlayOnStart
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetPlayOnStart(unmanagedPtr); }
            set { Internal_SetPlayOnStart(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should randomize the start time on play begin.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation"), EditorOrder(60), Tooltip("Determines whether the scene animation should randomize the start time on play begin.")]
        public bool RandomStartTime
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetRandomStartTime(unmanagedPtr); }
            set { Internal_SetRandomStartTime(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets or sets the value that determinates whether the scene animation should restore initial state on playback stop.
        /// </summary>
        [UnmanagedCall]
        [EditorDisplay("Scene Animation", "Restore State On Stop"), EditorOrder(70), Tooltip("Determines whether the scene animation should restore initial state on playback stop.")]
        public bool RestoreStateOnStop
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetRestoreStateOnStop(unmanagedPtr); }
            set { Internal_SetRestoreStateOnStop(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Gets the value that determinates whether the scene animation is playing.
        /// </summary>
        [UnmanagedCall]
        public bool IsPlaying
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetIsPlaying(unmanagedPtr); }
#endif
        }

        /// <summary>
        /// Gets the value that determinates whether the scene animation is paused.
        /// </summary>
        [UnmanagedCall]
        public bool IsPaused
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetIsPaused(unmanagedPtr); }
#endif
        }

        /// <summary>
        /// Gets the value that determinates whether the scene animation is stopped.
        /// </summary>
        [UnmanagedCall]
        public bool IsStopped
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetIsStopped(unmanagedPtr); }
#endif
        }

        /// <summary>
        /// Gets or sets the current animation playback time position (seconds).
        /// </summary>
        [UnmanagedCall]
        [NoSerialize, HideInEditor]
        public float Time
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetTime(unmanagedPtr); }
            set { Internal_SetTime(unmanagedPtr, value); }
#endif
        }

        /// <summary>
        /// Starts playing the animation. Has no effect if animation is already playing.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public void Play()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Play(unmanagedPtr);
#endif
        }

        /// <summary>
        /// Pauses the animation. Has no effect if animation is not playing.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public void Pause()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Pause(unmanagedPtr);
#endif
        }

        /// <summary>
        /// Stops playing the animation. Has no effect if animation is already stopped.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public void Stop()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Stop(unmanagedPtr);
#endif
        }

        #region Internal Calls

#if !UNIT_TEST_COMPILANT
        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern SceneAnimation Internal_GetAnimation(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetAnimation(IntPtr obj, IntPtr val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern float Internal_GetSpeed(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetSpeed(IntPtr obj, float val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern float Internal_GetStartTime(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetStartTime(IntPtr obj, float val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetUseTimeScale(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetUseTimeScale(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetLoop(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetLoop(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetPlayOnStart(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetPlayOnStart(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetRandomStartTime(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetRandomStartTime(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetRestoreStateOnStop(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetRestoreStateOnStop(IntPtr obj, bool val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetIsPlaying(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetIsPaused(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GetIsStopped(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern float Internal_GetTime(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_SetTime(IntPtr obj, float val);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Play(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Pause(IntPtr obj);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Stop(IntPtr obj);
#endif

        #endregion
    }
}

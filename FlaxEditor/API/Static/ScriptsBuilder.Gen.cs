// Copyright (c) 2012-2020 Wojciech Figat. All rights reserved.
// This code was generated by a tool. Changes to this file may cause
// incorrect behavior and will be lost if the code is regenerated.

using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace FlaxEditor.Scripting
{
    /// <summary>
    /// Game scrips building service. Compiles user C# scripts into binary assemblies.
    /// </summary>
    public static partial class ScriptsBuilder
    {
        /// <summary>
        /// Gets amount of source code compile actions since Editor startup.
        /// </summary>
        [UnmanagedCall]
        public static int CompilationsCount
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetCompilationsCount(); }
#endif
        }

        /// <summary>
        /// Gets the solution file path.
        /// </summary>
        [UnmanagedCall]
        public static string SolutionPath
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_GetSolutionPath(); }
#endif
        }

        /// <summary>
        /// Returns true if source code has been edited since last compilation.
        /// </summary>
        [UnmanagedCall]
        public static bool IsSourceDirty
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_IsSourceDirty(); }
#endif
        }

        /// <summary>
        /// Returns true if source code has been compiled and assemblies are ready to load.
        /// </summary>
        [UnmanagedCall]
        public static bool IsReady
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_IsReady(); }
#endif
        }

        /// <summary>
        /// Checks if last scripting building failed due to errors.
        /// </summary>
        [UnmanagedCall]
        public static bool LastCompilationFailed
        {
#if UNIT_TEST_COMPILANT
            get; set;
#else
            get { return Internal_LastCompilationFailed(); }
#endif
        }

        /// <summary>
        /// Indicates that scripting directory has been modified so scripts need to be rebuild.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static void MarkWorkspaceDirty()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_MarkWorkspaceDirty();
#endif
        }

        /// <summary>
        /// Requests project source code compilation.
        /// </summary>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static void Compile()
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            Internal_Compile();
#endif
        }

        /// <summary>
        /// Generates Visual Studio solution and project files for project as a plugin.
        /// </summary>
        /// <param name="assemblyName">Assembly name for the plugin.</param>
        /// <returns>True if cannot generate project files, otherwise false.</returns>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static bool GeneratePluginProject(string assemblyName)
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            return Internal_GeneratePluginProject(assemblyName);
#endif
        }

        /// <summary>
        /// Generates solution and project files.
        /// </summary>
        /// <param name="forceGenerateSolution">True if generate solution file by force even if there is no need to.</param>
        /// <param name="forceGenerateProject">True if generate project files by force even if there is no need to.</param>
        /// <returns>True if cannot perform that action, otherwise false.</returns>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static bool GenerateProject(bool forceGenerateSolution, bool forceGenerateProject)
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            return Internal_GenerateProject(forceGenerateSolution, forceGenerateProject);
#endif
        }

        /// <summary>
        /// Tries to find a script type with the given name.
        /// </summary>
        /// <param name="name">The script full name.</param>
        /// <returns>Found script type or null if missing or invalid name.</returns>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static Type FindScript(string name)
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            return Internal_FindScript(name);
#endif
        }

        /// <summary>
        /// Compiles the specified solution project.
        /// </summary>
        /// <remarks>
        /// It does not fire any CompileBegin, CompileEnd or other events except compilation warnings and errors. Also does not fires any scripting assemblies reload or any other actions. Scripts compilation is performed on a separate process.
        /// </remarks>
        /// <param name="solutionPath">The solution path (normalized, full path).</param>
        /// <param name="configuration">The build configuration.</param>
        /// <returns>True if failed, otherwise false.</returns>
#if UNIT_TEST_COMPILANT
        [Obsolete("Unit tests, don't support methods calls.")]
#endif
        [UnmanagedCall]
        public static bool Compile(string solutionPath, BuildMode configuration)
        {
#if UNIT_TEST_COMPILANT
            throw new NotImplementedException("Unit tests, don't support methods calls. Only properties can be get or set.");
#else
            return Internal_Compile2(solutionPath, configuration);
#endif
        }

        #region Internal Calls

#if !UNIT_TEST_COMPILANT
        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern int Internal_GetCompilationsCount();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern string Internal_GetSolutionPath();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_IsSourceDirty();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_IsReady();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_LastCompilationFailed();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_MarkWorkspaceDirty();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern void Internal_Compile();

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GeneratePluginProject(string assemblyName);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_GenerateProject(bool forceGenerateSolution, bool forceGenerateProject);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern Type Internal_FindScript(string name);

        [MethodImpl(MethodImplOptions.InternalCall)]
        internal static extern bool Internal_Compile2(string solutionPath, BuildMode configuration);
#endif

        #endregion
    }
}
